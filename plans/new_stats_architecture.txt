There are a handful of issues that are currently emerging with the way stats are handled at the moment:

- a ton of stats are "derived stats":
    > attributes w/ modifier effects
    > some way of getting base stats
    > derived performance stats (batting averages, etc)

- if 11/12 games are run in the background, we only need to update derived stats once at the back end.

- updating a running average every time will slowly cause drift from error accumulation
    > is this even a concern on our scale/precision?

- stats.py is a horrible mess

- indexing by "string" is kind of annoying, and could be improved
    > class member lookup?
    > enum?

- statshortener is kinda silly
    > abbreviations should be stored in the class database

- a stat should be an object all the time (instead of just some of the time?

- player indexing in general could be tuned? (index via stats class + player CID instead of player index?)

- auto-track if derived columns are "stale" and recompute only when necessary (end of game?)

- why is AllStats a singleton class when it could be a module?


oh god this is going to be horrid, isn't it.


here's the plan:

all stats are a Stats class instance in the top level module of stats

stats is designed to be imported as "import stats as s"

player indexing indexes off Stats primarily - passes a CID and Playerbase reference to stats
- keep string indexing as a fallback (don't break everything lol)

some stats are derived - they have dependent stats. If the dependent stats are modified, these stat categories become
stale, and must be recalculated every time. Otherwise, you can use the cached version.

Stats are stale per-player - they're their own columns

 - stale flags are player attributes instead of df columns? (faster)

- need to do python magic to transform definition with strings (or something) into lookups
- stats should have an init function
- personality needs a base personality also
- all stats (of a certain category?) should have a base - managed automatically by the stat?
- handle modifiers in a sane way


What is up with weights / descriptors / categories??
    - weight:
        did not used to be stats. used to be their own thing, which was maintained by all_stats.
        weights was pulled by descriptors.py and used to generate a descriptor
    - descriptor:
        a string that describes an aspect of a player. Weight --descriptors.py+playerdescriptors.py--> descriptors
    - category:
        a top level stat that summarizes a player's ability in an aspect of blaseball.
        "isn't that just weight" you might ask?
        well, yes - but it's processed somewhere else (right now) and displayed as a numeric.


ok open question:
what's the actual chain for indexing?

in the wider game, you're going to index like this:
    batter[s.earned_run_average]

without caching, the call chain for this looks like so:
    batter.__getitem__(s.earned_run_average)
    > disambiguation magic?
    >> earned_run_average.calculate_value(cid)
    >>> wrapper magic using embedded dataframe

but that disambiguation magic is the trick. Stats should just be pulling from the playerbase, for instance.
and with caching - why are we making player hold stats again?

it should be like:
    batter.__getitem__(s.earned_run_average)
    > earned_run_average.get(player_id)
    >> earned_run_average disambiguation magic
    >>> cache hit: earned_run_average > super().get()
    >>> cache miss: earned_run_average > earned_run_average.calculate_value()

except a lot of player nonsense (such as modifiers) will also update stats? so we really want caching to be on the
player level. so disregard the above!

something we keep running into:
    *playerbase*

playerbase is weird. It's a wrapper around the BIG STATS DATAFRAME, but it's also responsible for making and managing
players.

It probably shouldn't be in players?

the import chain should be like

playerbase > stats
playerbase > player

a stat is a way of accessing playerbase.
a player is another layer on top, as a way of accessing stats which access playerbase.

other views can lie on top of the same playerbase?


so how does getting a stat work?

given player-level caching:

    batter.__getitem__(s.battingaverage)
    > check batter.stale[s.battingaverage.kind]
    >> if stale:
    >>> s.battingaverage[batter.cid] + batter.modifiers[s.battingaverage]
    >> else:
    >>> batter.cache[s.battingaverage]


OK so really
What is up with weights / descriptors / categories??
    - weight:
        did not used to be stats. used to be their own thing, which was maintained by all_stats.
        weights was pulled by descriptors.py and used to generate a descriptor
    - descriptor:
        a string that describes an aspect of a player. Weight --descriptors.py+playerdescriptors.py--> descriptors
    - category:
        a top level stat that summarizes a player's ability in an aspect of blaseball.
        "isn't that just weight" you might ask?
        well, yes - but it's processed somewhere else (right now) and displayed as a numeric.

SO
a "weight" is a stat composed of a ratio of other stats.

so Categories (such as batting, baserunning) and descriptor weights (such as overall_fielding and utility_hitter)
are both weights.

a Descriptor is a Calculatable. it is based on other stats (specifically descriptor weights) relative to each other.
Descriptors pulls text from playerdescriptors.py

this is all fine.


What is a Rating?
a rating is a specific type of Stat. It has a base version and a live version.
Base + modifiers = Live.



What is a modifier/trait?

A big part of blaseball is things that modify a player Some examples:
- character traits, such as Fiesty, Cold
- physical traits, such as Really Long Arms
- moods, such as "angry" or "sad"
- injuries, such as Sprained Ankle or Broken Wing
- blaseball things, such as Spicy or Repeating
- items, such as the Gunblade Bat or Metaphorical Shoes

These affect the following:
- personalities
- ratings
- on-field effects
- available events
- player interactions

All of these are Modifiers - things that a player has that have effects. 
This is vague, which is difficult, but they're bundled together becuase we need to check *all of them* when it comes
time to read a player's stat. 

These are the primary way for side systems (items, blessings, personality) to *temporarily* affect a player. 

 A player can have have dozens to hundreds of modifiers!


 How do these work?

RATINGS:
 - a player maintains their own modifier list
 - all modifiers inherit from Modifier

 - calculating a rating involves iterating through the modifier list
 (modifiers each have their own list of what they make stale)
 - a modifier *can* have a dict of stats if it needs to modify stats

 PERSONALITIES:
 - personalities are going to have to be ratings also, with the base/effective split
 - make sure to apply personality modifiers prior to stat generation, since these affect the BASE stat

 these are pending:
 ON-FIELD EFFECTS
 - modifiers *can* subscribe to events (somehow)
 - these can do function calls or even intercept / prevent normal functions from executing
 - maybe some chcek modifier system in disambiguate playball?

 AVAILABLE EVENTS / PLAYER INTERATIONS
 - modifiers will have a list of tags used to affect events / interactions
 - this is even less specified than on-field effects


 Can we review how the personality four work?

1. they're affected by modifiers, which means they need base_ versions
2. they're randomly generated, unlike ratings
3. are these ratings with a custom base?
(sure)



question about ratings:
base rating + modifiers = rating
rating represents a cache, effectively. But we could just have ratings and modifiers, and update the rating
whenever a modifiers changes.
If you need the base rating, you can reverse-calculate it.

pros:
- simpler
- less dealing with cache chains
- unlike performance stats, where they're written far more often than they're read, ratings are read constantly
- less memory

cons:
- you have to be careful about removing modifiers
- modifier interactions get dumb?

would you ever need the base modifiers?
- sorting by base stats?
-


... we should pull the base split.