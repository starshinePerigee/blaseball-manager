There are a handful of issues that are currently emerging with the way stats are handled at the moment:

- a ton of stats are "derived stats":
    > attributes w/ modifier effects
    > some way of getting base stats
    > derived performance stats (batting averages, etc)

- if 11/12 games are run in the background, we only need to update derived stats once at the back end.

- updating a running average every time will slowly cause drift from error accumulation
    > is this even a concern on our scale/precision?

- stats.py is a horrible mess

- indexing by "string" is kind of annoying, and could be improved
    > class member lookup?
    > enum?

- statshortener is kinda silly
    > abbreviations should be stored in the class database

- a stat should be an object all the time (instead of just some of the time?

- player indexing in general could be tuned? (index via stats class + player CID instead of player index?)

- auto-track if derived columns are "stale" and recompute only when necessary (end of game?)

- why is AllStats a singleton class when it could be a module?


oh god this is going to be horrid, isn't it.


here's the plan:

all stats are a Stats class instance in the top level module of stats

stats is designed to be imported as "import stats as s"

player indexing indexes off Stats primarily - passes a CID and Playerbase reference to stats
- keep string indexing as a fallback (don't break everything lol)

some stats are derived - they have dependent stats. If the dependent stats are modified, these stat categories become
stale, and must be recalculated every time. Otherwise, you can use the cached version.

Stats are stale per-player - they're their own columns

 - stale flags are player attributes instead of df columns? (faster)

- need to do python magic to transform definition with strings (or something) into lookups
- stats should have an init function
- personality needs a base personality also
- all stats (of a certain category?) should have a base - managed automatically by the stat?
- handle modifiers in a sane way


What is up with weights / descriptors / categories??
    - weight:
        did not used to be stats. used to be their own thing, which was maintained by all_stats.
        weights was pulled by descriptors.py and used to generate a descriptor
    - descriptor:
        a string that describes an aspect of a player. Weight --descriptors.py+playerdescriptors.py--> descriptors
    - category:
        a top level stat that summarizes a player's ability in an aspect of blaseball.
        "isn't that just weight" you might ask?
        well, yes - but it's processed somewhere else (right now) and displayed as a numeric.

# TODO: this needs to get hashed out

ok open question:
what's the actual chain for indexing?

in the wider game, you're going to index like this:
    batter[s.earned_run_average]

without caching, the call chain for this looks like so:
    batter.__getitem__(s.earned_run_average)
    > disambiguation magic?
    >> earned_run_average.calculate_value(cid)
    >>> wrapper magic using embedded dataframe

but that disambiguation magic is the trick. Stats should just be pulling from the playerbase, for instance.
and with caching - why are we making player hold stats again?

it should be like:
    batter.__getitem__(s.earned_run_average)
    > earned_run_average.get(player_id)
    >> earned_run_average disambiguation magic
    >>> cache hit: earned_run_average > super().get()
    >>> cache miss: earned_run_average > earned_run_average.calculate_value()


something we keep running into:
    *playerbase*

playerbase is weird. It's a wrapper around the BIG STATS DATAFRAME, but it's also responsible for making and managing
players.

It probably shouldn't be in players?

the import chain should be like

playerbase > stats
playerbase > player

a stat is a way of accessing playerbase.
a player is another layer on top, as a way of accessing stats which access playerbase.

other views can lie on top of the same playerbase?